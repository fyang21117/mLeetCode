/*
* 20191127
* 递归代码模板：
*
*/
public void recur(int level, int param){

	//terminator
	//process result
	    if(level > MAX_LEVEL){
	    	return;
	    }
	
	//process current logic
	process(level, param);
	
	//drill down
	recur( level : level + 1, new Param);

	//restore current status
}




/*
* 20191127
* 分治代码模板：
*
*/
def divide_conquer(problem, param1, param2, ...):
	#recursion terminator
	if problem is None:
	  print_result
	  return

	#prepare data
	data = prepare_data(problem)
	subproblems = split_problem(problem, data)

	#conquer subproblems
	subresult1 = self.divide_conquer(subproblems[0], p1, ...)
	subresult2 = self.divide_conquer(subproblems[1], p1, ...)
	subresult3 = self.divide_conquer(subproblems[2], p1, ...)
	...

	#process and generate the final result
	result = process_result(subresult1, subresult2, subresult3, ...)

	#revert the current level states



/*
* 20191127
* DFS代码模板：
*
*/
(1)递归写法：
visited = set()

def dfs(node, visited):

    #terminator
    #already visited
    if node in visited:
	return

    visited.add(node)

    #process current node here...
	for next_node in node.children():
	    if not next_node in visited:
		dfs(next_node, visited)

(2)非递归写法：
def DFS(self,tree):

    if tree.root is None:
	return []

    visited, stack = [],[tree.root]

    while stack:
	node = stack.pop()
	visited.add(node)

	process(node)
	node = generate_related_nodes(node)
	stack.push(nodes)

	#other processing work


/*
* 20191127
* BFS代码模板：
*
*/
def BFS(graph, start, end)
	queue = []
	queue.append([start])

	while queue:
	    node = queue.pop()
	    visited.add(node)
	
	    process(node)
	    nodes = generate_related_nodes(node)
	    queue.push(nodes)

	#other processing work


/*
* 20191127
* 二分查找代码模板：
*
*/

left, right = 0, len(array)-1

while left <=right :
	mid = (left +right)/2

	#find the target
	if array[mid] == target:
	    break or return result

	elif array[mid] < target:
		left = mid + 1
	else:
		right = mid - 1
		

/*
* 20191127
* A*代码模板：
* 高级搜索
*/

def AstarSearch(graph, start, end):

    #优先级 -> 估价函数
    pq = collections.priority_queue()
    pq.append([start])
    visited.add(start)

    while pq:
	node = pq.pop()	#can add more intelligence here?
	visited.add(node)
	
	process(node)
	nodes = generate_related_nodes(node)
	unvisited = [node for node in nodes if node not in visited]
	pq.push(unvisited)


/**
 * //二叉树遍历
 * //前序遍历：根左右。中序：左根右。后序：左右根
 * //Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public List<Integer> preorderTraversal(final TreeNode root) {
        final List<Integer>res = new ArrayList<>();
        helper(root,res);
        return res;
    }
    public void helper(final TreeNode root,final List<Integer>res){
        if(root != null){
            res.add(root.val);
            if(root.left != null){
                helper(root.left,res);
            }
            if(root.right != null){
                helper(root.right,res);
            }
        }
    }
}

/*
* 20191127
* 位运算比取模等运算更快
*/
【判断奇偶】
ｘ％２＝＝１　－＞　（ｘ＆１）＝＝１
ｘ％２＝＝０　－＞　（ｘ＆１）＝＝０

【除以２】
ｘ／２　－＞　ｘ＞＞１
ｍｉｄ＝（Ｌ＋Ｒ）／２　－＞ｍｉｄ＝（Ｌ＋Ｒ）＞＞１

【清零最低位的１】
ｘ＝ｘ＆（ｘ－１）

【得到最低位的１。其中-X: 取反加一】
ｘ＆－ｘ		＝＞最低位的１
（ｘ＆～ｘ）	＝＞０




/*
* 20191128
* 初级排序--O(n^2)
*/

1.选择排序（Selection Sort）
  每次找最小值，然后放到待排序数组的起始位置。

代码模板：
public int[] selectionSort(final int []arr){
	final int len = arr.length;
	int minIndex,temp;
	for(int i=0;i<len-1;i++){
	   minIndex = i;
	   for(int j=i+1;j<len;j++){
		if(arr[j] < arr[minIndex])
			minIndex = j;
	   }
	   temp = arr[i];
	   arr[i] = arr[minIndex];
	   arr[minIndex] = temp;
	}
	return arr;
}



2.插入排序（Insertion Sort）
  从前到后逐步构建有序序列；对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

代码模板：
public int[] insertionSort(final int []arr){
	final int len = arr.length;
	int preIndex , current;
	for(int i=1;i<len;i++){
	   preIndex = i-1;
	   current = arr[i];
	   while(preIndex >=0 && arr[preIndex]>current){
	   	arr[preIndex + 1] = arr[preIndex];
		preIndex --;
	   }
	arr[preIndex+1] = current;
	}
	return arr;
}


3.冒泡排序（Bubble Sort）
  嵌套循环，每次查看相邻的元素如果逆序，则交换。

代码模板：
public int[] bubbleSort(final int []arr){
	final int len = arr.length;
	int temp;
	for(int i=0;i<len-1;i++){
	   for(int j=i+1;j<len;j++){
		if(arr[i] > arr[j]){
			temp = arr[i];
			arr[i] = arr[j];
			arr[j] = tmp;
		}
	   }
	}
	return arr;
}


/*
* 20191128
* 高级排序--O(nlogn)
*/

1.快速排序（Quick Sort）
数组取标杆pivot，将小元素放pivot左边，大元素放pivot右边，然后依次对左边和右边的子数组继续快排，以达到整个序列有序。

代码模板：
public static void quickSort(final int []array,final int begin,final int end){
	if(end <= begin) return;
	final int pivot = partition(array,begin,end);
	quickSort(array,begin,pivot-1);
	quickSort(array,pivot+1,end);
}
static int partition(final int []a,final int begin,final int end){
	//pivot:标杆位置
	//counter：小于pivot的元素个数
	final int pivot = end;
	int counter = begin;
	for(int i=begin;i<end;i++){
	   if(a[i]<a[pivot]){
		final int temp = a[counter];
		a[counter] = a[i];
		a[i] = temp;
		counter++;
	   }
	}
	final int temp = a[pivot];
	a[piviot] = a[i];
	a[i] = temp;
	return counter;
}


2.归并排序（Merge Sort）--分治思想
(1)把长度为n的输入序列分成两个长度为n/2的子序列；
（2）对这两个子序列分别采用归并排序；
（3）将两个排序好的子序列合并成一个最终的排序序列。

代码模板：
public static void mergeSort(final int []array,final int left,final int right){
	if(right <= left) return;
	final int mid = (left + right)>>1;//(left+right)/2
	mergeSort(array,left,mid);
	mergeSort(array,mid+1,right);
	merge(array,left,mid,right);
}
public static void merge(final int []array,final int left,final int mid,final int right){
   //中间数组
   final int []temp = new int[right - left +1];
   int i =left,j =mid+1,k=0;

   while(i<=mid && j<=right){
	temp[k++] = arr[i]<=arr[j] ? arr[i++]:arr[j++];
   }
   while(i<=mid) temp[k++]=arr[i++];
   while(j<=right) temp[k++]=arr[j++];

   for(int p=0;p<temp.length;p++)
	arr[left+p] = temp[p];
   //System.arraycopy(a,start1,b,start2,length);
}

比较：
归并和快排具有相似性，但步骤顺序相反。
归并：先排序左右子数组，然后合并两个有序子数组。
快排：先调配出左右子数组，然后对于左右子数组进行排序。



/*
* 20191129
* 特殊排序--O(n)
*/

1.计数排序（Conuting Sort）
计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键值存储在额外开辟的数组空间中；然后依次把计数大于1的填充回原数组。


2.桶排序（Bucket Sort）
桶排序的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（可能使用别的排序算法或以递归方式）。


3.基数排序（Radix Sort）
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；以此类推，直到最高位。（有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序）。





/*
* 20191206
* 高级字符串操作--最长子串、子序列
*/
1.Longest common sequence（最长子序列）
(1)DP方程:
if(s1[i-1]==s2[j-1])
	dp[i][j]=dp[i-1][j-1]+1;
else
	dp[i][j]=max(dp[i-1][j],dp[i][j-1]);

2.Longest common substring(最长子串)
(1)DP方程:
if(s1[i-1]==s2[j-1])
	dp[i][j]=dp[i-1][j-1]+1;
else
	dp[i][j]=0;

3.Edit distance(编辑距离)

/*
* 20191207
* Rabin-Karp算法
*/
算法思想：
1.假设子串的长度为M（pat），目标字符串的长度为N（txt）
2.计算子串的hash值hash_pat
3.计算目标字符串txt中每个长度为M的子串的hash值（共需要计算N-M+1次）
4.比较hash值：如果不同必然不匹配；如果相同再使用朴素算法判断






















